---
_id: projects
_title:
_description:
_keywords:
_headline: some recent projects
entries:
- _headline: ldapsearch oneliners
  _uri:
  _date: '2014-12-06'
  _snippet_markdown: |
    [ldapsearch](http://linux.die.net/man/1/ldapsearch) is a command line tool for querying ldap. Sometimes you want to retrieve directory information and don't have access an administrative interface, or you want something that's scriptable -- that's when _ldapsearch_ comes in handy.
    
    handy environmental variables:

        export LDAP_HOST="ldap01.example.com"
        export LDAP_SEARCH_BASE="dc=foo,dc=bar" # the search base for your searches 
        export LDAP_BIND_DN="$USERNAME@foo.bar" the DistinguishedName to use when binding to the ldap host

        export LDAP_PASSWORD_ARG="-w" #prompts everytime the command is run
        export LDAP_PASSWORD_ARG="-W mysecurepassword" #stores your password to the ldap server in memory (probably a bad idea)

    here are some one-liners that I use pretty frequently:
    
        #list all groups
        #usage: ldaplistgroups
        alias ldaplistgroups='ldapsearch -x -h $LDAP_HOST -b "$LDAP_SEARCH_BASE" -D $LDAP_BIND_DN "(objectcategory=group)" * $LDAP_PASSWORD_ARG | grep "^dn:" | sed "s/.* CN=\([^,]*\),.*/\1/" | sort'

        #list all members of the given group
        #usage: ldapmembership "engineering-team"
        ldapmembership() { ldapsearch -x -h $LDAP_HOST -b "$LDAP_SEARCH_BASE" -D $LDAP_BIND_DN "(&(objectcategory=user)(memberof=CN=$1,OU=Distribution Groups,$LDAP_SEARCH_BASE))" * $LDAP_PASSWORD_ARG | grep ^mailNickname: | sed "s/mailNickname: //" | tr [A-Z] [a-z] | sort }

        #show the given user's entire ldap entry
        #usage: ldapuser "Matt Komo"
        ldapuser() { ldapsearch -x -h $LDAP_HOST -b "$LDAP_SEARCH_BASE" -D $LDAP_BIND_DN "(&(objectcategory=user)(CN=$1))" $LDAP_PASSWORD_ARG }

    and here is a slightly more complicated bash script that I use to retrieve all groups that a user is a member of (including recursive groups):
    
        #!/bin/bash

        #usage: ldapallgroups "Matt Komo"
        QUERY="(CN=$1)"

        echoerr() { echo "$@" 1>&2; }

        while [ "$(echo $QUERY | wc -c)" -gt "6" ]; do

            LDG=$(ldapsearch -x -h $LDAP_HOST -b "$LDAP_SEARCH_BASE" -D $LDAP_BIND_DN "$QUERY" 'memberOf' $LDAP_PASSWORD_ARG | grep "^memberOf: " | sed "s/memberOf: \([^,]*\),.*/\1/")
            if [ -n "$LDG" ]; then
                echoerr "next order groups: "
                echo "$LDG"
            fi
            QUERY=$(echo "(|($LDG))" | tr "\n" "&" | sed 's/\&$//' | sed "s/\&/)(/g");
            echoerr "next query: $QUERY"
        done

- _headline: a history of storage cost
  _uri: /cost-per-gigabyte-update
  _date: '2014-03-05'
  _snippet: |
    <a href="/cost-per-gigabyte" class="right-img" style="height: 136px;">
     <img style="border: none" alt="" src="/static/assets/hd-cost-photo.jpg"/>
    </a>
    I was shopping for a hard drive a few weeks ago and I was dumbfounded to see that there are now 1 terabyte drives for under $100. That's less than 10 cents per gigabyte!
    <br/><br/>
    I decided to look for some historic pricing information to see exactly how fast the cost of storage space has gone down over the last 30 years. If you guessed <span class="bold">very</span> quickly, you were right.
- _headline: hist - bash history forever!
  _uri:
  _date: '2012-02-16'
  _snippet_markdown: |
    When I first started spending a lot of time in a shell, I remember often getting a sinking feeling when a command I needed had just fallen off the `history` stack. Sure, you can adjust the number of entries stored in your bash history, but that didn't seem good enough.
    
    So I wrote a utility called *[hist](https://github.com/mkomo/hist)*. It allows me to do some things that are not possible with the standard builtin as well as some things that are not otherwise easy or straightforward:

    *  retain my history forever and aggregate it across computers
    *  immediately see commands that were executed in other terminal sessions.
    *  retain with each history entry information including: shell PID, exit code, and pwd at the time of execution.
    *  query my entire history efficiently using hist -ag $REGEXP, where $REGEXP can include the datetime, shell id, directory of execution or any part of the command
    
    It's simple to add hist to your bash environment:
    
    * clone the *hist* repo:
        
            git clone https://github.com/mkomo/hist.git
        
    * put hist in an executable path:
    
            ln -s hist/hist ~/bin/hist
    
    * register hist in your bash prompt command:
    
            function mkomoprompt {
                EXITSTATUS="$?"
                eval "`hist -r`"
            }
            
            export PROMPT_COMMAND=mkomoprompt
    
    now all of your history will be stored forever in *~/.bash_eternal_history* and you can query it at any time with commands like:
    
        # every time you've executed the apt-get command on this machine
        hist -ag apt-get
    or
    
        # every time command you've executed in this directory during the current shell session
        hist -cg `pwd`
        
    and see results like this:
        
        #pid, date, time, exit status, directory, command
        16420	2014-11-23 13:24:04	0	/home/mkomorowski	sudo apt-get install compiz-plugins-extra 
        16420	2014-11-23 13:24:53	130	/home/mkomorowski	sudo apt-get install compiz-plugins-extra 
        11962	2014-11-26 13:00:54	100	/home/mkomorowski	sudo apt-get install cvt
        11962	2014-12-05 03:36:08	0	/home/mkomorowski	sudo apt-get install pepperflashplugin-nonfree
        25065	2014-12-07 10:21:15	0	/home/mkomorowski/workspaces	sudo apt-get install vlc

    [enjoy!](https://github.com/mkomo/hist)
    
- _headline: what's your ideal weather?
  _uri: /weather-rankings
  _date: '2009-02-11'
  _snippet: |
    <a href="/weather-rankings" class="right-img" style="height: 259px;">
     <img style="border: none" alt="" src="/static/assets/nice-weather.jpg"/>
    </a>
    I've always been unsatisfied by those "Ten Cities with Unbeatable Weather"-type articles that you see in magazines every once in a while. Sure, everyone knows San Diego is nice, but I wanted something a little bit more quantifiable.
    <br/><br/>
    I compiled climate data from around the country (averages, records, precipitation) and wrote some code that ranked locations based on my own criteria for what constitutes the best weather. The end result was a set of maps that gave me an idea about which areas of the country are nicest (hint: the magazines weren't too far off).
